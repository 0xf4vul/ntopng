Custom Alert Endpoint
---------------------

Alert endpoints are lua script executed whenever an alert event occurs. An example
of alert endpoint is the email export endpoint, which sends email with alert information.

Users can define a custom alert endpoint to be called on alert events. The endpoint
could trigger, for example, an external bash script with custom logic.

The custom alert endpoint can be enabled as follows:

  1. Run `cp /usr/share/ntopng/scripts/lua/modules/alert_endpoints/{sample.lua,custom.lua}`
  2. Enable "Alerts to Third-Party Endpoints" from the "Alert Endpoints" settings
  3. Run `redis-cli set ntopng.prefs.alerts.custom_notifications_enabled 1`
  4. Restart ntopng

The file `/usr/share/ntopng/scripts/lua/modules/alert_endpoints/custom.lua` can then be
modified with custom logic.

Custom Alert Generation
-----------------------

Ntopng periodically checks the status of its internal elements, and determines if an
alert should be generated. This mechanism is scriptable so alerts can be generated
from custom scripts. Currently the user is limited to the alerts already available into
ntopng. In order to add new alert types, the lua table `alert_consts.alert_types` in
`scripts/lua/modules/alert_consts.lua` should be edited. The new alert type must have
a unique `alert_id` >= 0, a title and description. Moreover, a new
"type_info building function" should be added to the `alerts_api.lua` to describe
the alert type.

ntopng checks the following alarmable for possible alerts:

  - hosts
  - networks
  - interfaces

ntopng checks for alerts every minute, 5 minutes, hour and day.

The alert check modules are located under `scripts/callbacks/interface/alerts/{alarmable}` .
For example, hosts alert check modules are located under `scripts/callbacks/interface/alerts/host`.

Here is an example of a check module:

```
local alerts_api = require("alerts_api")
local alert_consts = require("alert_consts")

local check_module = {
  key = "active",
  check_function = alerts_api.threshold_check_function,
  local_only = true,
}

-- #################################################################

function check_module.get_threshold_value(granularity, info)
  return alerts_api.host_delta_val(check_module.key, granularity, info["total_activity_time"])
end

-- #################################################################

return check_module
```

and here is a description of the module fields:

  - `key` (mandatory): a key which identifies the check module
  - `check_function` (mandatory): a function which is responsible to check the alarmable state and
    trigger/release the alerts. It takes a `params` parameter with at least the following fields:
      - granularity: the script granularity
      - alert_entity: an entity_info describing the entity (e.g. it contains the host IP address and vlan)
      - entity_info: contains entity specific data (e.g. on hosts, it is the output of `Host:lua()`)
      - alert_config: the alert configuration. This is automatically extracted via the `key`.
      - check_module: a reference to the check module
    The `alerts_api.threshold_check_function` is an example of check function.
  - `local_only`: if true, only call the `check_function` on local hosts
  - `always_enabled`: if true, the `check_function` will be called even when there are is
     no `alert_config` for the entity
  - `str_granularity`: if specified, the `check_function` will only be called at the specified granularity

Into the `check_function`, the check module should check the alarmable entity state (through the `entity_info`)
and:

  - call `alerts_api.trigger(entity_info, type_info)` whenever the entity state is alerted
  - call `alerts_api.release(entity_info, type_info)` whenever the entity state is not alerted

Alerts state is kept internally so multiple trigger/releases of the same alert have no effect.
The `type_info` is specific of the alert_type and should be built using one of the "type_info building functions"
available into `alerts_api.lua`, for example `alerts_api.thresholdCrossType`.
